# ns.View

Вид представляет собой элемент интерфейса.
Он однозначно идентифицируется своим ключом, который строится во время инициализации.
Разный ключ всегда означает разный экземпляр вида.

Не стоит ожидать, что при изменении параметров будет перерисован тот же самый вид. Этого можно достичь, но в общем виде будет создан и отрисован новый экземпляр.

- [Декларация](#Декларация)
  - [Объект-декларация](#Объект-декларация)
    - [ctor](#ctor)
    - [events](#events)
      - [Встроенные события](#Встроенные события)
    - [methods](#methods)
    - [models](#models)
    - [params](#params)

## Декларация

Определение нового вида происходит через статическую функцию `ns.View.define`
```js
ns.View.define('viewName', viewDeclObject[, baseView])
```

### Объект-декларация

Объект-декларация состоит из следующих свойств.

#### ctor

`ctor` - это функция-конструтор. Обратите внимание, что он вызывается самым первым, до инициализации самого вида, т.о. в конструкторе еще не доступеы некоторые свойства.

Полностью готовый экземпляр бросает событие `ns-view-init`.

```
/**
 * @classdesc prj.vMyView
 * @augments ns.View
 */
ns.View.define('my-view', {
    /**
     * @constructs prj.vMyView
     */
    ctor: function() {
        this._state = 'initial';
        this.CONST = 100;
    }
});
```

#### `events`

`events` - объект с декларацией подписок на события, как DOM, так и noscript.

События с суффиксом `@show` вещаются во время показа view - `view.show()` - и снимаются во время `view.hide()`.
Аналогично, `@init` суффикс означает, что событие будет активировано на `ns-view-htmlinit` и деактивировано на `ns-view-htmldestroy` (это поведение поумолчанию).

##### Встроенные события
Список событий:
* ```ns-view-hide``` - view был скрыт и больше не виден на странице
* ```ns-view-htmldestroy``` - старая нода у view была заменена на новую
* ```ns-view-htmlinit``` - у view появилась новая нода
* ```ns-view-async``` - у async-view появилась заглушка. Это единственное событие, которое генерируется для заглушки async-view
* ```ns-view-show``` - view был показан и теперь виден на странице
* ```ns-view-repaint``` - view виден и был затронут в процессе обновления страницы

1. События генерируются снизу вверх, т.е. сначала их получают дочерние view, потом родительские.
2. События генерируются пачками, т.е. сначала одно событие у всех view, потом другое событие у всех view.
3. События генерируются в строго определенном порядке:

```
ns-view-hide
ns-view-htmldestroy
ns-view-htmlinit
ns-view-async
ns-view-show
ns-view-repaint
```

Примеры последовательностей событий:
* инициализация view: ```ns-view-htmlinit -> ns-view-show -> ns-view-repaint```
* перерисовка страница, если view валиден: ```ns-view-repaint```
* view был скрыт: ```ns-view-hide``` (без ```ns-view-repaint```)
* view был показан: ```ns-view-show -> ns-view-repaint```
* view был обновлене: ```ns-view-hide -> ns-view-htmldestroy -> ns-view-htmlinit -> ns-view-show -> ns-view-repaint``` (```ns-view-hide``` тут вызывается из тех соображений, что могут быть обработчики, которые вешаются на ```ns-view-show/ns-view-hide``` и при обновлении ноды, они должны быть переинициализированы)

#### methods

`methods` - объект с методами вида. По сути является прототипом объекта.

```
/**
 * @classdesc prj.vMyView
 * @augments ns.View
 */
ns.View.define('my-view', {
    /** @lends prj.vMyView.prototype
    methods: {
        BAR: 100
        foo: function(){}
    }
});
```

#### models

`models` - массив с названиями моделей, от которых зависит вид.

#### params

Если **массив**: в массиве указываются группы параметров, чтобы можно было строить ключ по-разному в зависимости от того, что за параметры пришли в урле.
```js
ns.View.define('super-view', {
  params: [
    { "context": "album", "album-id": null },
    { "context": null }
  ]
});
```

Как строится ключ:
- для каждой группы из массива:
- каждое свойство объекта — это параметр урла, нужный для построения ключа
- если значение свойства `null` — параметр обязателен, но значение его может быть любым
- если значение свойства не `null` — это **фильтр**: параметр из урла должен иметь именно это значение (NOTE сейчас там везде `string`)
- если есть все нужные параметры и выполняются все фильтры — ключ можно строить
- иначе — пытаемся строить по следующей группе параметров

Если **объект** — тоже самое, что массив из одного элемента (см. выше).

Т.о. при использовании `params` все параметры являются обязательными. Чтобы сделать их необязательными, используйте `params+`.

В `next` есть красивый способ сделать все параметры опциональными:
```js
ns.View.define('view', {
  // ns.key - готовая функция для склеивания хеша с параметрами в строку
  params: ns.key
})
```

Если `params` **не указан** — параметры строятся по параметрам моделей `info.models`:
```js
ns.View.define('super-view', {
  models: [ 'album', 'photo' ]
});
```
- объединяются `model.info.params` в порядке их объявления в `view.info.models` (NOTE: тут получается некоторый приоритет: чем позднее указана модель, тем приоритетнее значения её параметров. Это не специально и это не продумывали отдельно)
- конкретные значения, указанные в `model.params`, становятся **значениями поумолчанию** при построении ключа view.

Если `params` явно заданы — нельзя использовать `params+` / `params-` (о них ниже).

Если ключ view нельзя построить кидается **ошибка**.

##### `params+`
В случае, когда набор параметров view строится по параметрам моделей можно добавить в результирующий набор дополнительные параметры:
```js
ns.View.define('super-view', {
  "models": [ 'album', 'photo' ],
  "params+": { page: 23 }
});
```

##### `params-`
Для удаления части параметров из ключа можно использовать `params-`:
```js
ns.View.define('super-view', {
  "models": [ 'album', 'photo' ],
  "params-": [ 'album-id' ]
});
```
